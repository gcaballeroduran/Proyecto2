using gold.structures.automaton.*
using gold.visualization.automaton.*

procedure main(args:String[]) begin
	// GAutomataFrame.show(createTransducer())
    lexer = createTransducer()
	 testLexer(lexer)
end
  
        

procedure testLexer(M:ITransducer) begin
	var sc:java.util.Scanner(System.$in)
    	
	input = ""
		
		
		print "----------------------------"
		print "Enter one or more lines. End with a single line with $"
       print "If you want to stop testing, enter EXIT"
       string:=sc.nextLine() 



	while string != "EXIT" do
		
		
       
       while string.charAt(0) != '$' do
              input := input + string + " "
              string:=sc.nextLine()
       end
       
       result:=M.acceptsString(input)    
		tokenStream := M.getOutputString()
		
		print "The lexer did "+(result?"":"not ")+" accept the string."
		if result then print "Token Stream: "+ tokenStream end		

       print "----------------------------"
	
	   print "Enter one or more lines. End with a single line with $"
       print "If you want to stop testing, enter EXIT"
       string:=sc.nextLine() 

	end
print  "Good bye"
print  ""

end 

 


var names
  
function createTransducer():ITransducer begin
	// Lexer: reads a string with lower casae letters, digits, parenthesis, and spaces.
	// outputs a string of {'(',')','+','*','v','n'}

	
	Q:= {"R","RV","s" ,"n", "nc" ,"ncn", "l", "lp", "lpl" ,"lplp", "lplc", "lplcl", "lplclp","lplclpf","lplpf","Err"}
	
	Σ:= ('a' ‥ 'z') ∪ {'(',')',' ','\n','{','}',';','!','[',']',','} ∪ ('A' ‥ 'Z')
	Out:={'(',')','+','*','v','n'} 
	q₀:="R"
	F:= {"R"}
	return 	GDeterministicTransducer(Q,Σ,Out,q₀,F,δ,g,h)
end

function δ(q,σ) begin
	if (q = "Err") then return "Err"
    elseif q="R" and σ='R' then return "R"
	elseif q="R" and σ='V' then return "RV"
	elseif q="RV" and σ ∈ ('a' ‥ 'z') then return "n"
	elseif	q="n" and σ = ',' then return "nc"
	elseif	q="nc" and σ ∈ ('a' ‥ 'z') then return "ncn"
	
	elseif	q="lplclpf" and σ ∈ ('A' ‥ 'Z') then return "l"
    elseif	q="lplpf" and σ ∈ ('A' ‥ 'Z') then return "l"
	elseif	q="ncn" and σ ∈ ('A' ‥ 'Z') then return "l"
	elseif	q="l" and σ = '(' then return "lp"
	elseif q="lp" and σ ∈ ('A' ‥ 'Z') then return "lpl" 
		
	elseif	q="lpl" and σ = ')' then return "lplp"
    elseif q="lplp" and σ=';' then return "lplpf"
    
    
	elseif	q="lpl" and σ = ',' then return "lplc"
    elseif q="lplc" and σ ∈ ('A' ‥ 'Z') then return "lplcl"
    elseif	q="lplcl" and σ = ')' then return "lplclp"
    elseif	q="lplclp" and σ = ';' then return "lplclpf"
    
    else  return "R"
    end	
end 



function g(q) begin
	return λ
end

function h(q,σ) begin
	var s: String
	s := λ

	if q ∉ {"Err"} then return s
	else return  λ
	end
end